pipeline {
    agent any

    environment {
        IMAGE_NAME = "my-go-app"
        HOME = "${WORKSPACE}"
        SONARQUBE_SERVER = "MySonarQube"
    }

    parameters {
        booleanParam(name: 'skip_test', defaultValue: false, description: 'Set to true to skip the test stage')
        booleanParam(name: 'sonar', defaultValue: false, description: 'Set to true to skip the test stage')
    }

    options {
        // Discard old builds
        buildDiscarder(logRotator(
            numToKeepStr: '10',          // keep last 10 builds
            daysToKeepStr: '30',         // OR builds from last 30 days
            artifactNumToKeepStr: '5',   // keep last 5 artifact sets
            artifactDaysToKeepStr: '15'  // OR artifacts from last 15 days
        ))
    }

    stages {
        
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    def fullGitSha = env.GIT_COMMIT
                    def shortGitSha = fullGitSha.substring(0,7)

                    echo "short git sha:${shortGitSha}"

                    env.SHORT_SHA = shortGitSha
                }
            }
        }


        stage('Lint') {
            agent {
                docker {
                image 'golang:1.23'
                args '-v $PWD:/app -w /app'
                }

            }

            steps {
                sh 'curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/HEAD/install.sh | sh -s -- -b $(go env GOPATH)/bin v2.4.0'
                sh 'golangci-lint --version'
                sh 'golangci-lint run ./... || true'
            }

            post {
                always {
                     recordIssues tools: [checkStyle(pattern: 'golangci-lint-report.xml')]
                    // archiveArtifacts 'golangci-lint-report.xml'
                }
            }


        }
        
        stage('Go Build & Test') {    
            agent {
                docker {
                image 'golang:1.23'
                args '-v $PWD:/app -w /app'
                }

            }

            environment {
                GOCACHE = '/tmp/go-cache'
            }
            steps {
                sh 'go version'
                sh 'go install github.com/jstemmer/go-junit-report@latest'

                sh 'go mod tidy'
                sh 'go test -v -coverprofile=coverage.out ./... | go-junit-report > report.xml'
                sh 'go tool cover -html=coverage.out -o coverage.html'
            }
            post {
                always {
                    junit 'report.xml'
                   // cobertura coberturaReportFile: 'coverage.xml', autoUpdateHealth: false, autoUpdateStability: false
                    archiveArtifacts artifacts: 'coverage.out, coverage.html, report.xml', fingerprint: true
                }
            }
        }

        stage('Build Docker Image') {

                when {
                    branch 'main'
                }
        
                steps {
                    script {
                        // This Dockerfile does the real build (multi-stage)
                        docker.build("${IMAGE_NAME}:latest")
                        
                    }

                    script{

                        def sha = env.SHORT_SHA
                        sh "docker tag ${IMAGE_NAME}:latest localhost:5000/${IMAGE_NAME}:${sha}"
                    }


                    sh "docker push  localhost:5000/${IMAGE_NAME}:${env.SHORT_SHA}"

                    script{

                        def sha = env.SHORT_SHA
                        sh "docker rmi  localhost:5000/${IMAGE_NAME}:${sha}"
                    }

                
                }
        }

        stage('kubernetes Manifest building') {
            when {
                branch 'main'
            }

            environment {
             // Assume you are using the build number as the image tag
                NEW_IMAGE_TAG = ${SHORT_SHA}
                // Set the path to your kustomization file
                KUSTOMIZE_FILE = "resources/kustomization.yaml"
            }

            steps {
                    dir('gitops-repo') {

                        git branch: 'main', credentialsId: 'gitea-server', url: 'http://host.docker.internal:3000/company/orchestration.git'

                        sh "git checkout main"
                        
                        // Now proceed with your sed and git commands
                        sh "sed -i 's#IMAGE_TAG_PLACEHOLDER#${NEW_IMAGE_TAG}#g' resources/kustomization.yaml"
                        sh '''
                            git config user.email "jenkins@example.com"
                            git config user.name "Jenkins Automation"
                            git add .
                            git commit -m "Updated image tag via Jenkins pipeline"
                            git remote -v
                        '''

                        withCredentials([usernamePassword(credentialsId: 'gitea-server', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
                            sh '''
                                git push http://$GIT_USER:$GIT_PASS@host.docker.internal:3000/company/orchestration.git HEAD:main
                            '''
                        
                         }
                    }
                        
            }

            // steps {
            //     // Use a credentials binding to securely expose the username and password variables.
            //     withCredentials([usernamePassword(credentialsId: 'gitea-server', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
            //         // Switch to the subdirectory for GitOps manifests
            //         dir('gitops-repo') {
            //             // Clone the repository with credentials
            //             git branch: 'main', credentialsId: 'gitea-server', url: 'http://host.docker.internal:3000/company/orchestration.git'

            //             // Update the kustomization.yaml file with the new image tag
            //             sh "sed -i 's#IMAGE_TAG_PLACEHOLDER#${NEW_IMAGE_TAG}#g' resources/kustomization.yaml"
                        
            //             // Commit and push the changes
            //             sh '''
            //                 git config user.email "jenkins@example.com"
            //                 git config user.name "Jenkins Automation"
            //                 git add .
            //                 git commit -m "Updated image tag via Jenkins pipeline"
                            
            //                 # Use git push with the credentials directly, and make sure to use single quotes or withEnv to avoid interpolation
            //                 git -c http.extraheader="Authorization: Basic $(echo -n ${GIT_USERNAME}:${GIT_PASSWORD} | base64)" push origin main
            //             '''
            //         }
            //     }
            // }
    

            // stage {

            //     stages{
                    
            //     dir('git-ops') {
                
            //         steps {
            //             checkout([$class: 'GitSCM',
            //                 branches: [[name: '*/main']],
            //                 userRemoteConfigs: [[
            //                     url: 'http://host.docker.internal:3000/company/orchestration.git',
            //                     credentialsId: 'gitea-server'
            //                 ]]
            //             ])
            //         }
            //     }

               

                
            //         steps {
            //             script {
            //                 sh '''
            //                     echo "Build timestamp: $(date)" >> build.log
            //                     sh "sed -i 's#IMAGE_TAG_PLACEHOLDER#${NEW_IMAGE_TAG}#g' resources/kustomization.yaml"
            //                     git add .

            //                     git commit -m "Add build log from Jenkins"
            //                 '''
            //             }
            //         }
            //     }

                
            //         steps {
            //             withCredentials([usernamePassword(credentialsId: 'gitea-creds', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
            //                 sh '''
            //                     git config user.email "jenkins@gitea.local"
            //                     git config user.name "Jenkins CI"
            //                     git push http://$GIT_USER:$GIT_PASS@host.docker.internal:3000/company/orchestration.git HEAD:main
            //                 '''
                        
            //         }
            //     }
            // }

        }

        stage('Deploy Locally') {

            when {
                branch 'main'
            }

            steps {
                sh 'docker rm -f my-go-app || true'
                sh 'docker run -d -p 8500:8500 --name my-go-app my-go-app:latest'
            }
        }
    
        stage('SAST Scan with gosec') {

            agent {
                docker {
                image 'golang:1.24.3'
                args '-v $PWD:/app -w /app'
                }

            }

            steps {
                // Installs gosec if not already present
                sh 'go install github.com/securego/gosec/v2/cmd/gosec@latest'
                // Run gosec and fail the build if vulnerabilities are found
                sh 'gosec -fmt=junit-xml -out=gosec-report.xml ./...'
            }
            post {
                always {
                    // Archive the report for later analysis
                    junit allowEmptyResults: true, testResults: 'gosec-report.xml'
                }
            }
        
        }

        //  stage('SCA Scan with govulncheck') {
        //      agent {
        //         docker {
        //         image 'golang:1.24.3'
        //         args '-v $PWD:/app -w /app'
        //     }
        //     }
        //     steps {
        //         // Run govulncheck and fail if vulnerable code is reachable
        //         sh 'go install golang.org/x/vuln/cmd/govulncheck@latest'
        //         sh 'govulncheck ./...'
        //     }
        // }

        stage('SCA Scan with govulncheck') {

            agent {
                docker {
                image 'golang:1.24.3'
                args '-v $PWD:/app -w /app'
                }

            }
            steps {
                sh 'go install golang.org/x/vuln/cmd/govulncheck@latest'
                sh 'govulncheck -format sarif  ./... >  govulncheck-report.sarif'
            }
            post {
                always {
                    // Publish the SARIF report using the warnings-ng plugin
                    recordIssues(
                        tools: [sarif(pattern: 'govulncheck-report.sarif')],
                        name: 'Go Vulnerability Scan'
                    )
                    // Archive the report as an artifact for easy download
                    archiveArtifacts 'govulncheck-report.sarif'
                }
            }
        }

        
        stage('SonarQube Analysis') {
            steps {


                execute_stage('SonarQube Analysis', false){
                    withSonarQubeEnv("${SONARQUBE_SERVER}") {
                    script {
                        def scannerHome = tool 'SonarScanner'
                        sh """
                        "${scannerHome}/bin/sonar-scanner" 
                        """
                    }
                    }
                }
            } 
        }

        stage('Quality Gate') {
                steps {

                    execute_stage('Quality Gate',false) {
                        timeout(time: 1, unit: 'HOURS') {
                        waitForQualityGate abortPipeline: false
                        // waitForQualityGate abortPipeline: true
                        }
                    }
                }
        }
    }

    post{
        always {
            cleanup()
        }
    }
}



def execute_stage(stage_name, skip, Closure steps) {
    if (skip) {
        echo "Skipping ${stage_name} stage"
    } else {
        steps.call()
    }
}
