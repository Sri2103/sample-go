pipeline {
    agent any

    environment {
        IMAGE_NAME = "my-go-app"
        HOME = "${WORKSPACE}"
        SONARQUBE_SERVER = "MySonarQube"
    }

    parameters {
        booleanParam(name: 'skip_test', defaultValue: false, description: 'Set to true to skip the test stage')
        booleanParam(name: 'sonar', defaultValue: false, description: 'Set to true to skip the test stage')
    }

    stages {
        
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    def fullGitSha = env.GIT_COMMIT
                    def shortGitSha = fullGitSha.substring(0,7)

                    echo "short git sha:${shortGitSha}"

                    env.SHORT_SHA = shortGitSha
                }
            }
        }


        stage('Lint') {
            agent {
                 docker {
                    image 'golangci/golangci-lint:v2.4.0'
                    args '-v $PWD:/app -w /app'
                }
            }

            steps {
                 sh 'golangci-lint run ./... --out-format checkstyle  > golangci-lint-report.xml || true'
            }

            post {
                always {
                     recordIssues tools: [checkStyle(pattern: 'golangci-lint-report.xml')]
                    // archiveArtifacts 'golangci-lint-report.xml'
                }
            }


        }
        
        stage('Go Build & Test') {    
            agent {
                docker {
                image 'golang:1.23'
                args '-v $PWD:/app -w /app'
                }

            }

            environment {
                GOCACHE = '/tmp/go-cache'
            }
            steps {
                sh 'go version'
                sh 'go install github.com/jstemmer/go-junit-report@latest'

                sh 'go mod tidy'
                sh 'go test -v -coverprofile=coverage.out ./... | go-junit-report > report.xml'
                sh 'go tool cover -html=coverage.out -o coverage.html'
            }
            post {
                always {
                    junit 'report.xml'
                   // cobertura coberturaReportFile: 'coverage.xml', autoUpdateHealth: false, autoUpdateStability: false
                    archiveArtifacts artifacts: 'coverage.out, coverage.html, report.xml', fingerprint: true
                }
            }
        }




        stage('Build Docker Image') {

                when {
                    branch 'main'
                }
        
                steps {
                    script {
                        // This Dockerfile does the real build (multi-stage)
                        docker.build("${IMAGE_NAME}:latest")
                        
                    }

                    script{

                        def sha = env.SHORT_SHA
                        sh "docker tag ${IMAGE_NAME}:latest localhost:5000/${IMAGE_NAME}:${sha}"
                    }


                    sh "docker push  localhost:5000/${IMAGE_NAME}:${env.SHORT_SHA}"

                    script{

                        def sha = env.SHORT_SHA
                        sh "docker rmi  localhost:5000/${IMAGE_NAME}:${sha}"
                    }

                
                }
        }

        stage('Deploy Locally') {

            when {
                branch 'main'
            }

            steps {
                sh 'docker rm -f my-go-app || true'
                sh 'docker run -d -p 8500:8500 --name my-go-app my-go-app:latest'
            }
        }
    
        stage('SAST Scan with gosec') {

            agent {
                docker {
                image 'golang:1.24.3'
                args '-v $PWD:/app -w /app'
                }

            }

            steps {
                // Installs gosec if not already present
                sh 'go install github.com/securego/gosec/v2/cmd/gosec@latest'
                // Run gosec and fail the build if vulnerabilities are found
                sh 'gosec -fmt=junit-xml -out=gosec-report.xml ./...'
            }
            post {
                always {
                    // Archive the report for later analysis
                    junit allowEmptyResults: true, testResults: 'gosec-report.xml'
                }
            }
        
        }

        //  stage('SCA Scan with govulncheck') {
        //      agent {
        //         docker {
        //         image 'golang:1.24.3'
        //         args '-v $PWD:/app -w /app'
        //     }
        //     }
        //     steps {
        //         // Run govulncheck and fail if vulnerable code is reachable
        //         sh 'go install golang.org/x/vuln/cmd/govulncheck@latest'
        //         sh 'govulncheck ./...'
        //     }
        // }

        stage('SCA Scan with govulncheck') {

            agent {
                docker {
                image 'golang:1.24.3'
                args '-v $PWD:/app -w /app'
                }

            }
            steps {
                sh 'go install golang.org/x/vuln/cmd/govulncheck@latest'
                sh 'govulncheck -format sarif  ./... >  govulncheck-report.sarif'
            }
            post {
                always {
                    // Publish the SARIF report using the warnings-ng plugin
                    recordIssues(
                        tools: [sarif(pattern: 'govulncheck-report.sarif')],
                        name: 'Go Vulnerability Scan'
                    )
                    // Archive the report as an artifact for easy download
                    archiveArtifacts 'govulncheck-report.sarif'
                }
            }
        }

        
        stage('SonarQube Analysis') {
            steps {


                execute_stage('SonarQube Analysis', false){
                    withSonarQubeEnv("${SONARQUBE_SERVER}") {
                    script {
                        def scannerHome = tool 'SonarScanner'
                        sh """
                        "${scannerHome}/bin/sonar-scanner" 
                        """
                    }
                    }
                }
            } 
        }

        stage('Quality Gate') {
                steps {

                    execute_stage('Quality Gate',false) {
                        timeout(time: 1, unit: 'HOURS') {
                        waitForQualityGate abortPipeline: false
                        // waitForQualityGate abortPipeline: true
                        }
                    }
                }
        }
    }
}



def execute_stage(stage_name, skip, Closure steps) {
    if (skip) {
        echo "Skipping ${stage_name} stage"
    } else {
        steps.call()
    }
}
